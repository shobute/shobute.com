<p><a href="https://projecteuler.net/problem=461">Problem 461</a> asks:</p>
<blockquote>
    <p>Let \(f_n(k) = e^{k/n} - 1\), for all non-negative integers \(k\).</p>
    <p>Let \(g(n) = a^2 + b^2 + c^2 + d^2\) for \(a, b, c, d\) that minimize: \(| f_n(a) + f_n(b) + f_n(c) + f_n(d) - \pi |\).</p>
    <p>Find \(g(10000)\).</p>
</blockquote>
<p>I solved this using C:</p>
<pre>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;math.h>

#define SIZE (15000/2 * (15000 + 1))
#define PI 3.14159265358979323846

double f_10000 (double k) {
    return exp(k/10000) - 1;
}

struct pair {
    int a;
    int b;
    double sum;
};

int cmp (const void *_a, const void *_b) {
    double a = ((const struct pair *)_a)->sum;
    double b = ((const struct pair *)_b)->sum;
 
   return (a > b) - (a &lt; b);
}

int main (void) {
    struct pair *pairs = malloc(SIZE * sizeof(struct pair));

    int k = 0;
    for (int i = 0; i &lt; 15000; i++) {
        for (int j = i; j &lt; 15000; j++) {
            pairs[k].a = i;
            pairs[k].b = j;
            pairs[k].sum = f_10000(i) + f_10000(j);
            k++;
        }
    }

    qsort(pairs, SIZE, sizeof(struct pair), cmp);

    double closest[3] = { 1, 0, 0 };
    for (int i = 0; i &lt; SIZE; i++) {
        int min = 0;
        int max = SIZE;
        int mid;
        while (max >= min) {
            mid = (min + max) / 2;
            if (pairs[i].sum + pairs[mid].sum &lt;= PI) min = mid + 1;
            else max = mid -1;
        }
        double error = fabs(pairs[i].sum + pairs[mid].sum - PI);
        if (error &lt; closest[0]) {
            closest[0] = error;
            closest[1] = i;
            closest[2] = mid;
        }
    }

    int a = pairs[(int)closest[1]].a;
    int b = pairs[(int)closest[1]].b;
    int c = pairs[(int)closest[2]].a;
    int d = pairs[(int)closest[2]].b;

    printf("%d^2 + %d^2 + %d^2 + %d^2 = %d\n", a, b, c, d, a*a + b*b + c*c + d*d);
}
</pre>
<p>It runs in just under a minute (on a 3.5 GHz CPU). I will improve the code and update this post shortly with a full explanation of the technique I used.</p>
